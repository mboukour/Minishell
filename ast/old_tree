#include "../minishell.h"

void set_condition_count(t_middle *first, t_middle *last)
{
	t_middle *f_clone;
	t_middle *l_clone;
	int condition_count;

	condition_count = 0;
	f_clone = first;
	l_clone = last;
	while(f_clone && f_clone != l_clone)
	{
		f_clone->condition_count = 0;
		f_clone->is_in_para = false;
		f_clone = f_clone->next;
	}
	while(first && first != last)
	{
		first->condition_count = condition_count;
		if(first->token == AND || first->token == OR)
			condition_count++;
		else if (first->token == OPEN_PARANTHESE)
		{
			while(first->token != CLOSE_PARANTHESE)
			{
				first->condition_count = condition_count;
				first->is_in_para = true;
				first = first->next;
			}
			first->condition_count = condition_count;
		}
		first = first->next;
	}
}



void print_ascii_tree(t_treenode *root, int level)
{
	t_middle *lol;
    if (root == NULL)
	{
		printf("\n");
        return;
	}

    // Print the right child
    print_ascii_tree(root->right, level + 1);

    // Print the current node
    for (int i = 0; i < level; i++)
        printf("    ");
    // printf("%s\n", root->content);
	lol = root->first;
	if(root->is_terminal)
		printf("%s ==> Terminal // Root is: %p", root->first->content, root);
	else
	{
		while(lol != root->last)
		{
			printf("%s ", lol->content);
			lol = lol->next;
		}
		printf("%s ==> Non-terminal // Root is: %p", lol->content, root);

	}

    // Print the left child
    print_ascii_tree(root->left, level + 1);
}


t_treenode *setup_condition(t_middle *current_middle ,int mode)
{
	t_middle *king_node;
	t_middle *looping_node;
	int current_cc;
	int counter;

	counter = 0;
	current_cc = current_middle->condition_count;
	if(mode == LEFT)
	{
		king_node = current_middle->prev;
		looping_node = king_node;
		while(looping_node->condition_count == current_cc)
		{
			counter++;
			if(looping_node->prev)
				looping_node = looping_node->prev;
			else
				break;
		}
		if(counter == 1)
			return (ft_lstnew_treenode(king_node, NULL, true));
		return (ft_lstnew_treenode(looping_node, king_node, false));
	}
	else
	{
		king_node = current_middle->next;
		looping_node = king_node;
		while(looping_node->condition_count == current_cc + 1)
		{
			if(!looping_node->is_in_para)
			{
				if(looping_node->token == AND || looping_node->token == OR)
				{
					looping_node = looping_node->prev;
					break;
				}
			}
			counter++;
			if(looping_node->next)
				looping_node = looping_node->next;
			else
				break;
		}
		if (counter == 1) // NOT SO GOOD!!!!
			return (ft_lstnew_treenode(king_node, NULL, true));
		return (ft_lstnew_treenode(king_node, looping_node, false));
	}
}
int i = 0;
void setup_mini_tree(t_middle *first, t_middle *last,t_treenode **current_root)
{
	t_treenode *current_node;

	current_node = NULL;
	printf("RUN %i\n", i);
	ft_lstiter_middle(first, last);
	printf("--------------------------\n");
	if(i == 2)
		return;
	i++;
	// if(!first || (current_root && (*current_root) && (*current_root)->right->is_terminal))
	// 	return;
	printf("FIRST: %s // ", first->content);
	if(last)
		printf("LAST: %s // ", last->content);
	else
		printf("LAST: NULL //");
	if(current_root)
		printf("*CR: %p", *current_root);
	printf("\n");
	*current_root = NULL;
	set_condition_count(first, last);
	while(first && first != last)
	{
		if((first->token == OR || first->token == AND))
		{
			current_node = ft_lstnew_treenode(first, NULL ,true);

			if(!(*current_root))
			{
				(*current_root) = current_node;
				(*current_root)->left = setup_condition(first, LEFT);
				(*current_root)->right = setup_condition(first, RIGHT);
				if(!(*current_root)->left->is_terminal)
					setup_mini_tree((*current_root)->left->first->next, (*current_root)->left->last->prev, &(*current_root)->left);
				if(!(*current_root)->right->is_terminal)
					setup_mini_tree((*current_root)->right->first->next, (*current_root)->right->last->prev, &(*current_root)->right);
			}
			else
			{
				change_root_to(current_root, current_node);
				(*current_root)->right = setup_condition(first, RIGHT);
				if(!(*current_root)->right->is_terminal)
					setup_mini_tree((*current_root)->right->first->next, (*current_root)->right->last->prev, &(*current_root)->right);
			}
		}
		first = first->next;
	}

}

t_treenode *rdp(t_middle *middle)
{
	t_treenode **root;

	root = malloc(sizeof(t_treenode *));
	*root = NULL;
	setup_mini_tree(middle, NULL, root);
	// usleep()
	print_ascii_tree(*root, 0);
	return (NULL);
}



// TODO:
// 1. FIX NON TERMINAL
